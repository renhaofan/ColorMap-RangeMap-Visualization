#include "widget.h"
#include "ui_widget.h"





using namespace cv;
using std::string;
using std::cout;
using std::endl;

QImage cvMat2QImage(const Mat &mat)
{
    switch ( mat.type() )
      {
         // 8位4通道
         case CV_8UC4:
         {
            QImage image( mat.data, mat.cols, mat.rows, static_cast<int>(mat.step), QImage::Format_RGB32 );
            return image;
         }

         // 8位3通道
         case CV_8UC3:
         {
            QImage image( mat.data, mat.cols, mat.rows, static_cast<int>(mat.step), QImage::Format_RGB888 );
            return image.rgbSwapped();
         }

         // 8位单通道
         case CV_8UC1:
         {

            static QVector<QRgb>  sColorTable;
            // only create our color table once
            if ( sColorTable.isEmpty() )
            {
               for ( int i = 0; i < 256; ++i )
                  sColorTable.push_back( qRgb( i, i, i ) );
            }
            QImage image( mat.data, mat.cols, mat.rows, static_cast<int>(mat.step), QImage::Format_Indexed8 );
            image.setColorTable( sColorTable );
            return image;
         }
        case CV_16UC1:
        {
            cv::Mat tmp;
            double min;
            double max;
            cv::minMaxIdx(mat, &min, &max);
            // expand your range to 0..255. Similar to histEq();
            mat.convertTo(tmp, CV_8UC1, 255 / (max - min), -min);

            QImage image(tmp.cols, tmp.rows, QImage::Format_Indexed8);
                    // Set the color table (used to translate colour indexes to qRgb values)
            image.setColorCount(256);
            for(int i = 0; i < 256; i++)
            {
                image.setColor(i, qRgb(i, i, i));
            }
            // Copy input Mat
            uchar *pSrc = tmp.data;
            for(int row = 0; row < tmp.rows; row++)
            {
                uchar *pDest = image.scanLine(row);
                memcpy(pDest, pSrc, static_cast<size_t>(tmp.cols));
                pSrc += static_cast<size_t>(tmp.step);
            }
            return image;
        }

        default:
        {
            qDebug("Image format is not supported: depth=%d and %d channels\n", mat.depth(), mat.channels());
            break;
        }
      }
    return QImage();
}

cv::Mat image2autumn(const cv::Mat& src) {
    cv::Mat b = src.clone();
    if (src.type() != CV_8UC1) {
        double min;
        double max;
        cv::minMaxIdx(src, &min, &max);
        // expand your range to 0..255. Similar to histEq();
        src.convertTo(b, CV_8UC1, 255 / (max - min), -min);
    }
    cv::Mat g = b.clone();
    cv::Mat r = b.clone();
    unsigned char autumn_r[256] = { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 };
    unsigned char autumn_g[256] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255 };
    unsigned char autumn_b[256] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

    int channels = b.channels();

    int nRows = b.rows;
    int nCols = b.cols * channels;

    if (b.isContinuous())
    {
        nCols *= nRows;
        nRows = 1;
    }

    int i, j;
    uchar* pb, *pg, *pr;
    for (i = 0; i < nRows; ++i)
    {
        pb = b.ptr<uchar>(i);
        pg = g.ptr<uchar>(i);
        pr = r.ptr<uchar>(i);
        for (j = 0; j < nCols; ++j)
        {
            pb[j] = autumn_b[pb[j]];
            pg[j] = autumn_g[pg[j]];
            pr[j] = autumn_r[pr[j]];
        }
    }
    cv::Mat dst(b.size(), CV_8UC3);
    std::vector<cv::Mat> t = { b,g,r };
    cv::merge(t, dst);
    return dst;
}
cv::Mat image2bone(const cv::Mat& src) {
    cv::Mat b = src.clone();
    if (src.type() != CV_8UC1) {
        double min;
        double max;
        cv::minMaxIdx(src, &min, &max);
        // expand your range to 0..255. Similar to histEq();
        src.convertTo(b, CV_8UC1, 255 / (max - min), -min);
    }
    cv::Mat g = b.clone();
    cv::Mat r = b.clone();
    unsigned char bone_r[256] = { 0, 1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 18, 18, 19, 20, 21, 22, 23, 24, 24, 25, 26, 27, 28, 29, 30, 31, 32, 32, 33, 34, 35, 36, 37, 38, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 52, 53, 54, 55, 56, 57, 58, 59, 60, 60, 61, 62, 63, 64, 65, 66, 66, 67, 68, 69, 70, 71, 72, 73, 73, 74, 75, 76, 77, 78, 79, 80, 80, 81, 82, 83, 84, 85, 86, 87, 87, 88, 89, 90, 91, 92, 93, 94, 94, 95, 96, 97, 98, 99, 100, 101, 102, 102, 103, 104, 105, 106, 107, 108, 108, 109, 110, 111, 112, 113, 114, 115, 116, 116, 117, 118, 119, 120, 121, 122, 122, 123, 124, 125, 126, 127, 128, 129, 130, 130, 131, 132, 133, 134, 135, 136, 136, 137, 138, 139, 140, 141, 142, 143, 144, 144, 145, 146, 147, 148, 149, 150, 150, 151, 152, 153, 154, 155, 156, 157, 158, 158, 159, 160, 161, 162, 163, 164, 164, 165, 166, 167, 169, 170, 171, 172, 174, 175, 177, 178, 179, 181, 182, 184, 185, 186, 188, 189, 190, 192, 193, 195, 196, 197, 199, 200, 201, 203, 204, 206, 207, 208, 210, 211, 212, 214, 215, 216, 218, 219, 221, 222, 223, 225, 226, 228, 229, 230, 232, 233, 234, 236, 237, 239, 240, 241, 243, 244, 245, 247, 248, 250, 251, 252, 254, 255 };
    unsigned char bone_g[256] = { 0, 1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 18, 18, 19, 20, 21, 22, 23, 24, 24, 25, 26, 27, 28, 29, 30, 31, 32, 32, 33, 34, 35, 36, 37, 38, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 52, 53, 54, 55, 56, 57, 58, 59, 60, 60, 61, 62, 63, 64, 65, 66, 66, 67, 68, 69, 70, 71, 72, 73, 73, 74, 75, 76, 77, 78, 79, 80, 80, 81, 82, 83, 84, 85, 87, 88, 89, 90, 91, 93, 94, 95, 96, 97, 99, 100, 101, 102, 103, 105, 106, 107, 108, 110, 111, 112, 113, 114, 116, 117, 118, 119, 120, 122, 123, 124, 125, 126, 128, 129, 130, 131, 132, 134, 135, 136, 137, 138, 140, 141, 142, 143, 145, 146, 147, 148, 149, 151, 152, 153, 154, 155, 157, 158, 159, 160, 161, 163, 164, 165, 166, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 180, 181, 182, 183, 184, 186, 187, 188, 189, 190, 192, 193, 194, 195, 196, 198, 199, 200, 201, 202, 203, 203, 204, 205, 206, 207, 208, 209, 210, 210, 211, 212, 213, 214, 215, 216, 216, 217, 218, 219, 220, 221, 222, 223, 224, 224, 225, 226, 227, 228, 229, 230, 231, 231, 232, 233, 234, 235, 236, 237, 238, 238, 239, 240, 241, 242, 243, 244, 244, 245, 246, 247, 248, 249, 250, 251, 252, 252, 253, 254, 255 };
    unsigned char bone_b[256] = { 0, 1, 2, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 16, 17, 18, 19, 21, 22, 23, 24, 25, 27, 28, 29, 30, 31, 33, 34, 35, 36, 37, 39, 40, 41, 42, 43, 45, 46, 47, 48, 50, 51, 52, 53, 54, 56, 57, 58, 59, 60, 62, 63, 64, 65, 66, 68, 69, 70, 71, 72, 74, 75, 76, 77, 79, 80, 81, 82, 83, 85, 86, 87, 88, 89, 91, 92, 93, 94, 95, 97, 98, 99, 100, 102, 103, 104, 105, 106, 108, 109, 110, 111, 112, 113, 115, 116, 117, 118, 118, 119, 120, 121, 122, 123, 124, 125, 126, 126, 127, 128, 129, 130, 131, 132, 132, 133, 134, 135, 136, 137, 138, 139, 140, 140, 141, 142, 143, 144, 145, 146, 146, 147, 148, 149, 150, 151, 152, 153, 154, 154, 155, 156, 157, 158, 159, 160, 160, 161, 162, 163, 164, 165, 166, 167, 168, 168, 169, 170, 171, 172, 173, 174, 174, 175, 176, 177, 178, 179, 180, 181, 182, 182, 183, 184, 185, 186, 187, 188, 188, 189, 190, 191, 192, 193, 194, 195, 196, 196, 197, 198, 199, 200, 201, 202, 203, 203, 204, 205, 206, 207, 208, 209, 210, 210, 211, 212, 213, 214, 215, 216, 216, 217, 218, 219, 220, 221, 222, 223, 224, 224, 225, 226, 227, 228, 229, 230, 231, 231, 232, 233, 234, 235, 236, 237, 238, 238, 239, 240, 241, 242, 243, 244, 244, 245, 246, 247, 248, 249, 250, 251, 252, 252, 253, 254, 255 };

    int channels = b.channels();

    int nRows = b.rows;
    int nCols = b.cols * channels;

    if (b.isContinuous())
    {
        nCols *= nRows;
        nRows = 1;
    }

    int i, j;
    uchar* pb, *pg, *pr;
    for (i = 0; i < nRows; ++i)
    {
        pb = b.ptr<uchar>(i);
        pg = g.ptr<uchar>(i);
        pr = r.ptr<uchar>(i);
        for (j = 0; j < nCols; ++j)
        {
            pb[j] = bone_b[pb[j]];
            pg[j] = bone_g[pg[j]];
            pr[j] = bone_r[pr[j]];
        }
    }
    cv::Mat dst(b.size(), CV_8UC3);
    std::vector<cv::Mat> t = { b,g,r };
    cv::merge(t, dst);
    return dst;
}
cv::Mat image2cool(const cv::Mat& src) {
    cv::Mat b = src.clone();
    if (src.type() != CV_8UC1) {
        double min;
        double max;
        cv::minMaxIdx(src, &min, &max);
        // expand your range to 0..255. Similar to histEq();
        src.convertTo(b, CV_8UC1, 255 / (max - min), -min);
    }
    cv::Mat g = b.clone();
    cv::Mat r = b.clone();
    unsigned char cool_r[256] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255 };
    unsigned char cool_g[256] = { 255, 254, 253, 252, 251, 250, 249, 248, 247, 246, 245, 244, 243, 242, 241, 240, 239, 238, 237, 236, 235, 234, 233, 232, 231, 230, 229, 228, 227, 226, 225, 224, 223, 222, 221, 220, 219, 218, 217, 216, 215, 214, 213, 212, 211, 210, 209, 208, 207, 206, 205, 204, 203, 202, 201, 200, 199, 198, 197, 196, 195, 194, 193, 192, 191, 190, 189, 188, 187, 186, 185, 184, 183, 182, 181, 180, 179, 178, 177, 176, 175, 174, 173, 172, 171, 170, 169, 168, 167, 166, 165, 164, 163, 162, 161, 160, 159, 158, 157, 156, 155, 154, 153, 152, 151, 150, 149, 148, 147, 146, 145, 144, 143, 142, 141, 140, 139, 138, 137, 136, 135, 134, 133, 132, 131, 130, 129, 128, 127, 126, 125, 124, 123, 122, 121, 120, 119, 118, 117, 116, 115, 114, 113, 112, 111, 110, 109, 108, 107, 106, 105, 104, 103, 102, 101, 100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 };
    unsigned char cool_b[256] = { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 };

    int channels = b.channels();

    int nRows = b.rows;
    int nCols = b.cols * channels;

    if (b.isContinuous())
    {
        nCols *= nRows;
        nRows = 1;
    }

    int i, j;
    uchar* pb, *pg, *pr;
    for (i = 0; i < nRows; ++i)
    {
        pb = b.ptr<uchar>(i);
        pg = g.ptr<uchar>(i);
        pr = r.ptr<uchar>(i);
        for (j = 0; j < nCols; ++j)
        {
            pb[j] = cool_b[pb[j]];
            pg[j] = cool_g[pg[j]];
            pr[j] = cool_r[pr[j]];
        }
    }
    cv::Mat dst(b.size(), CV_8UC3);
    std::vector<cv::Mat> t = { b,g,r };
    cv::merge(t, dst);
    return dst;
}
cv::Mat image2hot(const cv::Mat& src) {
    cv::Mat b = src.clone();
    if (src.type() != CV_8UC1) {
        double min;
        double max;
        cv::minMaxIdx(src, &min, &max);
        // expand your range to 0..255. Similar to histEq();
        src.convertTo(b, CV_8UC1, 255 / (max - min), -min);
    }
    cv::Mat g = b.clone();
    cv::Mat r = b.clone();
    unsigned char hot_r[256] = { 0, 2, 5, 8, 10, 12, 15, 18, 20, 22, 25, 27, 30, 32, 35, 38, 40, 42, 45, 48, 50, 52, 55, 57, 60, 62, 65, 68, 70, 72, 75, 78, 80, 82, 85, 88, 90, 92, 95, 98, 100, 102, 105, 108, 110, 112, 115, 117, 120, 122, 125, 128, 130, 132, 135, 138, 140, 142, 145, 148, 150, 152, 155, 158, 160, 162, 165, 168, 170, 172, 175, 178, 180, 182, 185, 188, 190, 192, 195, 198, 200, 202, 205, 208, 210, 212, 215, 218, 220, 223, 225, 228, 230, 232, 235, 238, 240, 243, 245, 248, 250, 252, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 };
    unsigned char hot_g[256] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4, 6, 8, 10, 13, 15, 18, 20, 22, 25, 28, 30, 32, 35, 38, 40, 42, 45, 48, 50, 52, 55, 58, 60, 62, 65, 68, 70, 72, 75, 78, 80, 82, 85, 88, 90, 92, 95, 98, 100, 102, 105, 108, 110, 112, 115, 118, 120, 122, 125, 128, 130, 132, 135, 138, 140, 142, 145, 148, 150, 152, 155, 158, 160, 162, 165, 168, 170, 172, 175, 178, 180, 182, 185, 188, 190, 192, 195, 198, 200, 202, 205, 208, 210, 212, 215, 218, 220, 222, 225, 228, 230, 232, 235, 238, 240, 242, 245, 248, 250, 252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 };
    unsigned char hot_b[256] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 5, 8, 11, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 105, 110, 115, 120, 125, 130, 135, 140, 145, 150, 155, 160, 165, 170, 175, 180, 185, 190, 195, 200, 205, 210, 215, 220, 225, 230, 235, 240, 245, 250, 255 };

    int channels = b.channels();

    int nRows = b.rows;
    int nCols = b.cols * channels;

    if (b.isContinuous())
    {
        nCols *= nRows;
        nRows = 1;
    }

    int i, j;
    uchar* pb, *pg, *pr;
    for (i = 0; i < nRows; ++i)
    {
        pb = b.ptr<uchar>(i);
        pg = g.ptr<uchar>(i);
        pr = r.ptr<uchar>(i);
        for (j = 0; j < nCols; ++j)
        {
            pb[j] = hot_b[pb[j]];
            pg[j] = hot_g[pg[j]];
            pr[j] = hot_r[pr[j]];
        }
    }
    cv::Mat dst(b.size(), CV_8UC3);
    std::vector<cv::Mat> t = { b,g,r };
    cv::merge(t, dst);
    return dst;
}
cv::Mat image2hsv(const cv::Mat& src) {
    cv::Mat b = src.clone();
    if (src.type() != CV_8UC1) {
        double min;
        double max;
        cv::minMaxIdx(src, &min, &max);
        // expand your range to 0..255. Similar to histEq();
        src.convertTo(b, CV_8UC1, 255 / (max - min), -min);
    }
    cv::Mat g = b.clone();
    cv::Mat r = b.clone();
    unsigned char hsv_r[256] = { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 253, 250, 247, 244, 240, 234, 228, 222, 216, 210, 204, 198, 192, 186, 180, 174, 168, 162, 156, 150, 144, 138, 132, 126, 120, 114, 108, 102, 96, 90, 84, 78, 72, 66, 60, 54, 48, 42, 36, 30, 24, 18, 12, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 12, 18, 24, 30, 36, 42, 48, 54, 60, 66, 72, 78, 84, 90, 96, 102, 108, 114, 120, 126, 132, 138, 144, 150, 156, 162, 168, 174, 180, 186, 192, 198, 204, 210, 216, 222, 228, 234, 240, 244, 247, 250, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 };
    unsigned char hsv_g[256] = { 0, 6, 12, 18, 24, 30, 36, 42, 48, 54, 60, 66, 72, 78, 84, 90, 96, 102, 108, 114, 120, 126, 132, 138, 144, 150, 156, 162, 168, 174, 180, 186, 192, 198, 204, 210, 216, 222, 228, 234, 240, 244, 247, 250, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 253, 250, 247, 244, 240, 234, 228, 222, 216, 210, 204, 198, 192, 186, 180, 174, 168, 162, 156, 150, 144, 138, 132, 126, 120, 114, 108, 102, 96, 90, 84, 78, 72, 66, 60, 54, 48, 42, 36, 30, 24, 18, 12, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    unsigned char hsv_b[256] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 12, 18, 24, 30, 36, 42, 48, 54, 60, 66, 72, 78, 84, 90, 96, 102, 108, 114, 120, 126, 132, 138, 144, 150, 156, 162, 168, 174, 180, 186, 192, 198, 204, 210, 216, 222, 228, 234, 240, 244, 247, 250, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 253, 250, 247, 244, 240, 234, 228, 222, 216, 210, 204, 198, 192, 186, 180, 174, 168, 162, 156, 150, 144, 138, 132, 126, 120, 114, 108, 102, 96, 90, 84, 78, 72, 66, 60, 54, 48, 42, 36, 30, 24, 18, 12, 6, 0 };

    int channels = b.channels();

    int nRows = b.rows;
    int nCols = b.cols * channels;

    if (b.isContinuous())
    {
        nCols *= nRows;
        nRows = 1;
    }

    int i, j;
    uchar* pb, *pg, *pr;
    for (i = 0; i < nRows; ++i)
    {
        pb = b.ptr<uchar>(i);
        pg = g.ptr<uchar>(i);
        pr = r.ptr<uchar>(i);
        for (j = 0; j < nCols; ++j)
        {
            pb[j] = hsv_b[pb[j]];
            pg[j] = hsv_g[pg[j]];
            pr[j] = hsv_r[pr[j]];
        }
    }
    cv::Mat dst(b.size(), CV_8UC3);
    std::vector<cv::Mat> t = { b,g,r };
    cv::merge(t, dst);
    return dst;
}
cv::Mat image2jet(const cv::Mat& src) {
    cv::Mat b = src.clone();
    if (src.type() != CV_8UC1) {
        double min;
        double max;
        cv::minMaxIdx(src, &min, &max);
        // expand your range to 0..255. Similar to histEq();
        src.convertTo(b, CV_8UC1, 255 / (max - min), -min);
    }
    cv::Mat g = b.clone();
    cv::Mat r = b.clone();
    unsigned char jet_r[256] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 6, 10, 14, 18, 22, 26, 30, 34, 38, 42, 46, 50, 54, 58, 62, 66, 70, 74, 78, 82, 86, 90, 94, 98, 102, 106, 110, 114, 118, 122, 126, 130, 134, 138, 142, 146, 150, 154, 158, 162, 166, 170, 174, 178, 182, 186, 190, 194, 198, 202, 206, 210, 214, 218, 222, 226, 230, 234, 238, 242, 246, 250, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 252, 248, 244, 240, 236, 232, 228, 224, 220, 216, 212, 208, 204, 200, 196, 192, 188, 184, 180, 176, 172, 168, 164, 160, 156, 152, 148, 144, 140, 136, 132, 128 };
    unsigned char jet_g[256] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144, 148, 152, 156, 160, 164, 168, 172, 176, 180, 184, 188, 192, 196, 200, 204, 208, 212, 216, 220, 224, 228, 232, 236, 240, 244, 248, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 252, 248, 244, 240, 236, 232, 228, 224, 220, 216, 212, 208, 204, 200, 196, 192, 188, 184, 180, 176, 172, 168, 164, 160, 156, 152, 148, 144, 140, 136, 132, 128, 124, 120, 116, 112, 108, 104, 100, 96, 92, 88, 84, 80, 76, 72, 68, 64, 60, 56, 52, 48, 44, 40, 36, 32, 28, 24, 20, 16, 12, 8, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    unsigned char jet_b[256] = { 128, 132, 136, 140, 144, 148, 152, 156, 160, 164, 168, 172, 176, 180, 184, 188, 192, 196, 200, 204, 208, 212, 216, 220, 224, 228, 232, 236, 240, 244, 248, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 250, 246, 242, 238, 234, 230, 226, 222, 218, 214, 210, 206, 202, 198, 194, 190, 186, 182, 178, 174, 170, 166, 162, 158, 154, 150, 146, 142, 138, 134, 130, 126, 122, 118, 114, 110, 106, 102, 98, 94, 90, 86, 82, 78, 74, 70, 66, 62, 58, 54, 50, 46, 42, 38, 34, 30, 26, 22, 18, 14, 10, 6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

    int channels = b.channels();

    int nRows = b.rows;
    int nCols = b.cols * channels;

    if (b.isContinuous())
    {
        nCols *= nRows;
        nRows = 1;
    }

    int i, j;
    uchar* pb, *pg, *pr;
    for (i = 0; i < nRows; ++i)
    {
        pb = b.ptr<uchar>(i);
        pg = g.ptr<uchar>(i);
        pr = r.ptr<uchar>(i);
        for (j = 0; j < nCols; ++j)
        {
            pb[j] = jet_b[pb[j]];
            pg[j] = jet_g[pg[j]];
            pr[j] = jet_r[pr[j]];
        }
    }
    cv::Mat dst(b.size(), CV_8UC3);
    std::vector<cv::Mat> t = { b,g,r };
    cv::merge(t, dst);
    return dst;
}
cv::Mat image2ocean(const cv::Mat& src) {
    cv::Mat b = src.clone();
    if (src.type() != CV_8UC1) {
        double min;
        double max;
        cv::minMaxIdx(src, &min, &max);
        // expand your range to 0..255. Similar to histEq();
        src.convertTo(b, CV_8UC1, 255 / (max - min), -min);
    }
    cv::Mat g = b.clone();
    cv::Mat r = b.clone();
    unsigned char ocean_r[256] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99, 102, 105, 108, 111, 114, 117, 120, 123, 126, 129, 132, 135, 138, 141, 144, 147, 150, 153, 156, 159, 162, 165, 168, 171, 174, 177, 180, 183, 186, 189, 192, 195, 198, 201, 204, 207, 210, 213, 216, 219, 222, 225, 228, 231, 234, 237, 240, 243, 246, 249, 252, 255 };
    unsigned char ocean_g[256] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 6, 8, 9, 10, 12, 13, 15, 17, 18, 20, 21, 22, 24, 26, 27, 28, 30, 32, 33, 34, 36, 38, 39, 40, 42, 44, 45, 46, 48, 50, 51, 52, 54, 56, 57, 58, 60, 62, 63, 64, 66, 68, 69, 70, 72, 74, 75, 76, 78, 80, 81, 82, 84, 86, 87, 88, 90, 92, 93, 94, 96, 98, 99, 100, 102, 104, 105, 106, 108, 110, 111, 112, 114, 116, 117, 118, 120, 122, 123, 124, 126, 128, 129, 130, 132, 134, 135, 136, 138, 140, 141, 142, 144, 146, 147, 148, 150, 152, 153, 154, 156, 158, 159, 161, 162, 164, 165, 166, 168, 170, 171, 172, 174, 176, 177, 178, 180, 182, 183, 184, 186, 188, 189, 190, 192, 194, 195, 196, 198, 200, 201, 202, 204, 206, 207, 208, 210, 212, 213, 214, 216, 218, 219, 220, 222, 224, 225, 226, 228, 230, 231, 232, 234, 236, 237, 238, 240, 242, 243, 244, 246, 248, 249, 251, 252, 254, 255 };
    unsigned char ocean_b[256] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255 };

    int channels = b.channels();

    int nRows = b.rows;
    int nCols = b.cols * channels;

    if (b.isContinuous())
    {
        nCols *= nRows;
        nRows = 1;
    }

    int i, j;
    uchar* pb, *pg, *pr;
    for (i = 0; i < nRows; ++i)
    {
        pb = b.ptr<uchar>(i);
        pg = g.ptr<uchar>(i);
        pr = r.ptr<uchar>(i);
        for (j = 0; j < nCols; ++j)
        {
            pb[j] = ocean_b[pb[j]];
            pg[j] = ocean_g[pg[j]];
            pr[j] = ocean_r[pr[j]];
        }
    }
    cv::Mat dst(b.size(), CV_8UC3);
    std::vector<cv::Mat> t = { b,g,r };
    cv::merge(t, dst);
    return dst;
}
cv::Mat image2parula(const cv::Mat& src) {
    cv::Mat b = src.clone();
    if (src.type() != CV_8UC1) {
        double min;
        double max;
        cv::minMaxIdx(src, &min, &max);
        // expand your range to 0..255. Similar to histEq();
        src.convertTo(b, CV_8UC1, 255 / (max - min), -min);
    }
    cv::Mat g = b.clone();
    cv::Mat r = b.clone();
    unsigned char parula_r[256] = { 53, 51, 50, 48, 47, 45, 44, 42, 40, 39, 37, 36, 34, 33, 31, 29, 28, 26, 25, 23, 22, 20, 18, 17, 15, 14, 12, 11, 9, 8, 6, 4, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 19, 19, 20, 20, 19, 19, 19, 18, 18, 17, 17, 16, 16, 15, 15, 15, 14, 14, 13, 13, 12, 12, 12, 11, 11, 10, 10, 9, 9, 8, 8, 8, 7, 7, 6, 7, 8, 10, 11, 13, 14, 16, 18, 19, 21, 22, 24, 25, 27, 29, 30, 32, 33, 35, 36, 38, 40, 41, 43, 44, 46, 47, 49, 51, 52, 54, 55, 57, 60, 63, 66, 69, 72, 74, 77, 80, 83, 86, 88, 91, 94, 97, 100, 103, 105, 108, 111, 114, 117, 120, 122, 125, 128, 131, 134, 136, 139, 142, 145, 147, 150, 152, 154, 156, 159, 161, 163, 165, 167, 170, 172, 174, 176, 179, 181, 183, 185, 187, 190, 192, 194, 196, 199, 201, 203, 205, 208, 210, 212, 214, 216, 218, 219, 220, 221, 222, 223, 224, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 249, 250, 251, 252, 252, 252, 252, 252, 252, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 251, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 249, 249, 249, 249, 249, 249 };
    unsigned char parula_g[256] = { 42, 44, 46, 47, 49, 51, 53, 55, 56, 58, 60, 62, 63, 65, 67, 69, 71, 72, 74, 76, 78, 80, 81, 83, 85, 87, 88, 90, 92, 94, 96, 97, 99, 100, 101, 102, 103, 104, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 168, 169, 169, 170, 171, 171, 172, 172, 173, 173, 174, 175, 175, 176, 176, 177, 177, 178, 179, 179, 180, 180, 181, 181, 182, 182, 183, 184, 184, 185, 185, 185, 185, 186, 186, 186, 186, 186, 187, 187, 187, 187, 187, 188, 188, 188, 188, 188, 188, 189, 189, 189, 189, 189, 190, 190, 190, 190, 190, 191, 191, 191, 191, 191, 191, 190, 190, 190, 190, 190, 190, 189, 189, 189, 189, 189, 189, 189, 188, 188, 188, 188, 188, 188, 187, 187, 187, 187, 187, 187, 187, 186, 186, 186, 186, 187, 188, 188, 189, 190, 190, 191, 191, 192, 193, 193, 194, 195, 195, 196, 197, 197, 198, 198, 199, 200, 200, 201, 202, 202, 203, 203, 204, 205, 205, 206, 207, 209, 210, 211, 213, 214, 216, 217, 219, 220, 221, 223, 224, 226, 227, 228, 230, 231, 233, 234, 235, 237, 238, 240, 241, 243, 244, 245, 247, 248, 250, 251 };
    unsigned char parula_b[256] = { 135, 138, 141, 143, 146, 149, 152, 155, 158, 160, 163, 166, 169, 172, 175, 177, 180, 183, 186, 189, 191, 194, 197, 200, 203, 206, 208, 211, 214, 217, 220, 223, 225, 225, 224, 224, 223, 223, 223, 222, 222, 221, 221, 220, 220, 220, 219, 219, 218, 218, 218, 217, 217, 216, 216, 216, 215, 215, 214, 214, 214, 213, 213, 212, 212, 211, 211, 211, 210, 210, 209, 209, 208, 208, 208, 207, 207, 206, 206, 205, 205, 204, 204, 204, 203, 203, 202, 202, 201, 201, 200, 200, 200, 199, 199, 198, 198, 196, 195, 194, 193, 191, 190, 189, 187, 186, 185, 184, 182, 181, 180, 179, 177, 176, 175, 174, 172, 171, 170, 169, 167, 166, 165, 164, 162, 161, 160, 159, 157, 156, 155, 153, 152, 151, 149, 148, 147, 145, 144, 142, 141, 140, 138, 137, 136, 134, 133, 132, 130, 129, 128, 126, 125, 124, 122, 121, 120, 118, 117, 116, 114, 114, 113, 112, 111, 110, 109, 108, 107, 106, 105, 104, 104, 103, 102, 101, 100, 99, 98, 97, 96, 95, 94, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 81, 80, 79, 78, 76, 75, 74, 73, 71, 70, 69, 67, 66, 65, 64, 62, 61, 60, 59, 57, 56, 55, 54, 52, 51, 50, 49, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14 };

    int channels = b.channels();

    int nRows = b.rows;
    int nCols = b.cols * channels;

    if (b.isContinuous())
    {
        nCols *= nRows;
        nRows = 1;
    }

    int i, j;
    uchar* pb, *pg, *pr;
    for (i = 0; i < nRows; ++i)
    {
        pb = b.ptr<uchar>(i);
        pg = g.ptr<uchar>(i);
        pr = r.ptr<uchar>(i);
        for (j = 0; j < nCols; ++j)
        {
            pb[j] = parula_b[pb[j]];
            pg[j] = parula_g[pg[j]];
            pr[j] = parula_r[pr[j]];
        }
    }
    cv::Mat dst(b.size(), CV_8UC3);
    std::vector<cv::Mat> t = { b,g,r };
    cv::merge(t, dst);
    return dst;
}
cv::Mat image2pink(const cv::Mat& src) {
    cv::Mat b = src.clone();
    if (src.type() != CV_8UC1) {
        double min;
        double max;
        cv::minMaxIdx(src, &min, &max);
        // expand your range to 0..255. Similar to histEq();
        src.convertTo(b, CV_8UC1, 255 / (max - min), -min);
    }
    cv::Mat g = b.clone();
    cv::Mat r = b.clone();
    unsigned char pink_r[256] = { 0, 10, 20, 30, 40, 44, 48, 52, 56, 60, 63, 66, 69, 72, 74, 77, 80, 82, 84, 87, 89, 91, 93, 95, 98, 100, 101, 103, 105, 107, 109, 111, 113, 114, 116, 118, 119, 121, 123, 124, 126, 128, 129, 131, 132, 134, 135, 137, 138, 139, 141, 142, 144, 145, 146, 148, 149, 150, 152, 153, 154, 156, 157, 158, 159, 161, 162, 163, 164, 165, 167, 168, 169, 170, 171, 172, 174, 175, 176, 177, 178, 179, 180, 181, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 195, 196, 196, 197, 197, 198, 198, 198, 199, 199, 200, 200, 201, 201, 201, 202, 202, 203, 203, 203, 204, 204, 205, 205, 206, 206, 206, 207, 207, 208, 208, 208, 209, 209, 210, 210, 210, 211, 211, 212, 212, 212, 213, 213, 214, 214, 214, 215, 215, 216, 216, 216, 217, 217, 218, 218, 218, 219, 219, 220, 220, 220, 221, 221, 221, 222, 222, 223, 223, 223, 224, 224, 225, 225, 225, 226, 226, 226, 227, 227, 228, 228, 228, 229, 229, 229, 230, 230, 230, 231, 231, 232, 232, 232, 233, 233, 233, 234, 234, 235, 235, 235, 236, 236, 236, 237, 237, 237, 238, 238, 238, 239, 239, 240, 240, 240, 241, 241, 241, 242, 242, 242, 243, 243, 243, 244, 244, 244, 245, 245, 245, 246, 246, 247, 247, 247, 248, 248, 248, 249, 249, 249, 250, 250, 250, 251, 251, 251, 252, 252, 252, 253, 253, 253, 254, 254, 254, 255, 255 };
    unsigned char pink_g[256] = { 0, 6, 13, 19, 26, 29, 31, 34, 37, 39, 41, 43, 45, 47, 49, 50, 52, 54, 55, 57, 58, 60, 61, 62, 64, 65, 66, 68, 69, 70, 71, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 98, 99, 100, 101, 102, 103, 103, 104, 105, 106, 107, 108, 108, 109, 110, 111, 111, 112, 113, 114, 114, 115, 116, 117, 117, 118, 119, 119, 120, 121, 122, 122, 123, 124, 124, 125, 126, 127, 128, 129, 130, 131, 133, 134, 136, 137, 138, 140, 141, 143, 144, 145, 147, 148, 149, 151, 152, 153, 155, 156, 157, 159, 160, 161, 162, 163, 165, 166, 167, 168, 169, 171, 172, 173, 174, 175, 176, 177, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 197, 198, 199, 200, 201, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 227, 228, 229, 230, 231, 232, 232, 233, 233, 234, 234, 235, 235, 235, 236, 236, 236, 237, 237, 237, 238, 238, 238, 239, 239, 240, 240, 240, 241, 241, 241, 242, 242, 242, 243, 243, 243, 244, 244, 244, 245, 245, 245, 246, 246, 247, 247, 247, 248, 248, 248, 249, 249, 249, 250, 250, 250, 251, 251, 251, 252, 252, 252, 253, 253, 253, 254, 254, 254, 255, 255 };
    unsigned char pink_b[256] = { 0, 6, 13, 19, 26, 29, 31, 34, 37, 39, 41, 43, 45, 47, 49, 50, 52, 54, 55, 57, 58, 60, 61, 62, 64, 65, 66, 68, 69, 70, 71, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 98, 99, 100, 101, 102, 103, 103, 104, 105, 106, 107, 108, 108, 109, 110, 111, 111, 112, 113, 114, 114, 115, 116, 117, 117, 118, 119, 119, 120, 121, 122, 122, 123, 124, 124, 125, 126, 126, 127, 128, 128, 129, 130, 130, 131, 132, 132, 133, 134, 134, 135, 135, 136, 137, 137, 138, 139, 139, 140, 140, 141, 142, 142, 143, 143, 144, 145, 145, 146, 146, 147, 148, 148, 149, 149, 150, 150, 151, 151, 152, 153, 153, 154, 154, 155, 155, 156, 156, 157, 158, 158, 159, 159, 160, 160, 161, 161, 162, 162, 163, 163, 164, 164, 165, 165, 166, 166, 167, 167, 168, 168, 169, 169, 170, 170, 171, 171, 172, 172, 173, 173, 174, 174, 175, 175, 176, 176, 177, 177, 178, 178, 179, 179, 180, 181, 182, 183, 184, 186, 187, 188, 190, 191, 192, 194, 195, 196, 198, 199, 200, 201, 203, 204, 205, 206, 208, 209, 210, 211, 212, 214, 215, 216, 217, 218, 220, 221, 222, 223, 224, 225, 226, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255 };

    int channels = b.channels();

    int nRows = b.rows;
    int nCols = b.cols * channels;

    if (b.isContinuous())
    {
        nCols *= nRows;
        nRows = 1;
    }

    int i, j;
    uchar* pb, *pg, *pr;
    for (i = 0; i < nRows; ++i)
    {
        pb = b.ptr<uchar>(i);
        pg = g.ptr<uchar>(i);
        pr = r.ptr<uchar>(i);
        for (j = 0; j < nCols; ++j)
        {
            pb[j] = pink_b[pb[j]];
            pg[j] = pink_g[pg[j]];
            pr[j] = pink_r[pr[j]];
        }
    }
    cv::Mat dst(b.size(), CV_8UC3);
    std::vector<cv::Mat> t = { b,g,r };
    cv::merge(t, dst);
    return dst;
}
cv::Mat image2rainbow(const cv::Mat& src) {
    cv::Mat b = src.clone();
    if (src.type() != CV_8UC1) {
        double min;
        double max;
        cv::minMaxIdx(src, &min, &max);
        // expand your range to 0..255. Similar to histEq();
        src.convertTo(b, CV_8UC1, 255 / (max - min), -min);
    }
    cv::Mat g = b.clone();
    cv::Mat r = b.clone();
    unsigned char rainbow_r[256] = { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 252, 248, 244, 240, 235, 230, 225, 220, 215, 210, 205, 200, 195, 190, 185, 180, 175, 170, 165, 160, 155, 150, 145, 140, 135, 130, 125, 120, 115, 110, 105, 100, 95, 90, 85, 80, 75, 70, 65, 60, 55, 50, 45, 40, 35, 30, 25, 20, 15, 11, 7, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 5, 7, 10, 13, 17, 20, 23, 27, 30, 33, 37, 40, 43, 47, 50, 53, 57, 60, 63, 67, 70, 73, 77, 80, 83, 87, 90, 93, 97, 100, 103, 107, 110, 113, 117, 120, 123, 127, 130, 133, 137, 140, 143, 147, 150, 153, 157, 160, 163, 167, 170 };
    unsigned char rainbow_g[256] = { 0, 2, 5, 8, 10, 12, 15, 18, 20, 22, 25, 27, 30, 32, 35, 38, 40, 42, 45, 48, 50, 52, 55, 57, 60, 62, 65, 68, 70, 72, 75, 78, 80, 82, 85, 88, 90, 92, 95, 98, 100, 102, 105, 108, 110, 112, 115, 117, 120, 122, 125, 128, 130, 132, 135, 138, 140, 142, 145, 148, 150, 152, 155, 158, 160, 162, 165, 168, 170, 172, 175, 178, 180, 182, 185, 188, 190, 192, 195, 198, 200, 202, 205, 208, 210, 212, 215, 218, 220, 223, 225, 228, 230, 232, 235, 238, 240, 243, 245, 248, 250, 252, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 253, 252, 250, 245, 240, 235, 230, 225, 220, 215, 210, 205, 200, 195, 190, 185, 180, 175, 170, 165, 160, 155, 150, 145, 140, 135, 130, 125, 120, 115, 110, 105, 100, 95, 90, 85, 80, 75, 70, 65, 60, 55, 50, 45, 40, 35, 30, 25, 20, 15, 10, 7, 5, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    unsigned char rainbow_b[256] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 105, 110, 115, 120, 125, 130, 135, 140, 145, 150, 155, 160, 165, 170, 175, 180, 185, 190, 195, 200, 205, 210, 215, 220, 225, 230, 235, 240, 245, 248, 250, 252, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 };

    int channels = b.channels();

    int nRows = b.rows;
    int nCols = b.cols * channels;

    if (b.isContinuous())
    {
        nCols *= nRows;
        nRows = 1;
    }

    int i, j;
    uchar* pb, *pg, *pr;
    for (i = 0; i < nRows; ++i)
    {
        pb = b.ptr<uchar>(i);
        pg = g.ptr<uchar>(i);
        pr = r.ptr<uchar>(i);
        for (j = 0; j < nCols; ++j)
        {
            pb[j] = rainbow_b[pb[j]];
            pg[j] = rainbow_g[pg[j]];
            pr[j] = rainbow_r[pr[j]];
        }
    }
    cv::Mat dst(b.size(), CV_8UC3);
    std::vector<cv::Mat> t = { b,g,r };
    cv::merge(t, dst);
    return dst;
}
cv::Mat image2spring(const cv::Mat& src) {
    cv::Mat b = src.clone();
    if (src.type() != CV_8UC1) {
        double min;
        double max;
        cv::minMaxIdx(src, &min, &max);
        // expand your range to 0..255. Similar to histEq();
        src.convertTo(b, CV_8UC1, 255 / (max - min), -min);
    }
    cv::Mat g = b.clone();
    cv::Mat r = b.clone();
    unsigned char spring_r[256] = { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 };
    unsigned char spring_g[256] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255 };
    unsigned char spring_b[256] = { 255, 254, 253, 252, 251, 250, 249, 248, 247, 246, 245, 244, 243, 242, 241, 240, 239, 238, 237, 236, 235, 234, 233, 232, 231, 230, 229, 228, 227, 226, 225, 224, 223, 222, 221, 220, 219, 218, 217, 216, 215, 214, 213, 212, 211, 210, 209, 208, 207, 206, 205, 204, 203, 202, 201, 200, 199, 198, 197, 196, 195, 194, 193, 192, 191, 190, 189, 188, 187, 186, 185, 184, 183, 182, 181, 180, 179, 178, 177, 176, 175, 174, 173, 172, 171, 170, 169, 168, 167, 166, 165, 164, 163, 162, 161, 160, 159, 158, 157, 156, 155, 154, 153, 152, 151, 150, 149, 148, 147, 146, 145, 144, 143, 142, 141, 140, 139, 138, 137, 136, 135, 134, 133, 132, 131, 130, 129, 128, 127, 126, 125, 124, 123, 122, 121, 120, 119, 118, 117, 116, 115, 114, 113, 112, 111, 110, 109, 108, 107, 106, 105, 104, 103, 102, 101, 100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 };

    int channels = b.channels();

    int nRows = b.rows;
    int nCols = b.cols * channels;

    if (b.isContinuous())
    {
        nCols *= nRows;
        nRows = 1;
    }

    int i, j;
    uchar* pb, *pg, *pr;
    for (i = 0; i < nRows; ++i)
    {
        pb = b.ptr<uchar>(i);
        pg = g.ptr<uchar>(i);
        pr = r.ptr<uchar>(i);
        for (j = 0; j < nCols; ++j)
        {
            pb[j] = spring_b[pb[j]];
            pg[j] = spring_g[pg[j]];
            pr[j] = spring_r[pr[j]];
        }
    }
    cv::Mat dst(b.size(), CV_8UC3);
    std::vector<cv::Mat> t = { b,g,r };
    cv::merge(t, dst);
    return dst;
}
cv::Mat image2summer(const cv::Mat& src) {
    cv::Mat b = src.clone();
    if (src.type() != CV_8UC1) {
        double min;
        double max;
        cv::minMaxIdx(src, &min, &max);
        // expand your range to 0..255. Similar to histEq();
        src.convertTo(b, CV_8UC1, 255 / (max - min), -min);
    }
    cv::Mat g = b.clone();
    cv::Mat r = b.clone();
    unsigned char summer_r[256] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255 };
    unsigned char summer_g[256] = { 128, 128, 128, 129, 130, 130, 130, 131, 132, 132, 132, 133, 134, 134, 134, 135, 136, 136, 136, 137, 138, 138, 138, 139, 140, 140, 140, 141, 142, 142, 142, 143, 144, 144, 144, 145, 146, 146, 146, 147, 148, 148, 148, 149, 150, 150, 150, 151, 152, 152, 152, 153, 154, 154, 154, 155, 156, 156, 156, 157, 158, 158, 158, 159, 160, 160, 160, 161, 162, 162, 162, 163, 164, 164, 164, 165, 166, 166, 166, 167, 168, 168, 168, 169, 170, 170, 170, 171, 172, 172, 172, 173, 174, 174, 174, 175, 176, 176, 176, 177, 178, 178, 178, 179, 180, 180, 180, 181, 182, 182, 182, 183, 184, 184, 184, 185, 186, 186, 186, 187, 188, 188, 188, 189, 190, 190, 190, 191, 192, 192, 192, 193, 194, 194, 194, 195, 196, 196, 196, 197, 198, 198, 198, 199, 200, 200, 200, 201, 202, 202, 202, 203, 204, 204, 204, 205, 206, 206, 206, 207, 208, 208, 208, 209, 210, 210, 210, 211, 212, 212, 212, 213, 214, 214, 214, 215, 216, 216, 216, 217, 218, 218, 218, 219, 220, 220, 220, 221, 222, 222, 222, 223, 224, 224, 224, 225, 226, 226, 226, 227, 228, 228, 228, 229, 230, 230, 230, 231, 232, 232, 232, 233, 234, 234, 234, 235, 236, 236, 236, 237, 238, 238, 238, 239, 240, 240, 240, 241, 242, 242, 242, 243, 244, 244, 244, 245, 246, 246, 246, 247, 248, 248, 248, 249, 250, 250, 250, 251, 252, 252, 252, 253, 254, 254, 254, 255 };
    unsigned char summer_b[256] = { 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102 };

    int channels = b.channels();

    int nRows = b.rows;
    int nCols = b.cols * channels;

    if (b.isContinuous())
    {
        nCols *= nRows;
        nRows = 1;
    }

    int i, j;
    uchar* pb, *pg, *pr;
    for (i = 0; i < nRows; ++i)
    {
        pb = b.ptr<uchar>(i);
        pg = g.ptr<uchar>(i);
        pr = r.ptr<uchar>(i);
        for (j = 0; j < nCols; ++j)
        {
            pb[j] = summer_b[pb[j]];
            pg[j] = summer_g[pg[j]];
            pr[j] = summer_r[pr[j]];
        }
    }
    cv::Mat dst(b.size(), CV_8UC3);
    std::vector<cv::Mat> t = { b,g,r };
    cv::merge(t, dst);
    return dst;
}
cv::Mat image2turbo(const cv::Mat& src) {
    cv::Mat b = src.clone();
    if (src.type() != CV_8UC1) {
        double min;
        double max;
        cv::minMaxIdx(src, &min, &max);
        // expand your range to 0..255. Similar to histEq();
        src.convertTo(b, CV_8UC1, 255 / (max - min), -min);
    }
    cv::Mat g = b.clone();
    cv::Mat r = b.clone();
    unsigned char turbo_r[256] = { 48,50,51,52,53,54,55,56,57,58,59,60,61,62,63,63,64,65,65,66,66,67,68,68,68,69,69,69,70,70,70,70,70,71,71,71,71,71,71,70,70,70,70,70,69,69,68,67,66,65,64,62,61,59,58,56,55,53,51,49,47,46,44,42,40,39,37,35,34,32,31,30,28,27,26,26,25,24,24,24,24,24,24,25,25,26,28,29,31,32,34,37,39,42,44,47,50,53,56,60,63,67,70,74,78,82,85,89,93,97,101,105,109,113,117,121,125,128,132,136,139,143,146,150,153,156,159,161,164,167,169,172,175,177,180,183,185,188,190,193,195,198,200,203,205,208,210,212,215,217,219,221,223,225,227,229,231,233,235,236,238,239,241,242,244,245,246,247,248,249,250,251,251,252,252,253,253,254,254,254,254,254,254,254,254,254,254,253,253,252,252,251,251,250,249,249,248,247,246,245,244,243,242,241,240,239,237,236,235,234,232,231,229,228,226,225,223,221,220,218,216,214,212,210,208,206,204,202,200,197,195,193,190,188,185,183,180,178,175,172,169,167,164,161,158,155,152,149,146,142,139,136,133,129,126,122 };
    unsigned char turbo_g[256] = { 18,21,24,27,30,33,36,39,42,45,47,50,53,56,59,62,64,67,70,73,75,78,81,84,86,89,92,94,97,100,102,105,107,110,113,115,118,120,123,125,128,130,133,135,138,140,143,145,148,150,153,155,158,160,163,165,168,171,173,175,178,180,183,185,188,190,192,195,197,199,201,203,205,208,210,212,213,215,217,219,221,222,224,226,227,228,230,231,233,234,235,236,238,239,240,241,242,243,244,245,246,247,248,248,249,250,250,251,252,252,253,253,254,254,254,254,255,255,255,255,255,255,255,254,254,254,253,253,252,252,251,251,250,249,248,247,246,245,244,243,241,240,239,237,236,234,233,231,229,228,226,224,223,221,219,217,215,213,211,209,207,205,203,201,199,197,195,193,190,188,186,184,182,179,177,174,172,169,167,164,161,158,155,153,150,147,144,141,138,135,132,129,126,123,120,117,114,111,108,105,102,99,96,93,91,88,85,83,80,78,75,73,71,69,67,65,63,61,59,57,55,53,51,49,47,45,43,42,40,38,37,35,33,32,30,29,27,26,24,23,22,20,19,18,16,15,14,13,11,10,9,8,7,6,5,4 };
    unsigned char turbo_b[256] = { 59,67,74,81,88,95,102,109,115,121,128,134,139,145,151,156,162,167,172,177,181,186,191,195,199,203,207,211,214,218,221,224,227,230,233,235,238,240,242,244,246,248,250,251,252,253,254,254,255,255,255,254,254,253,252,251,250,248,247,245,244,242,240,238,235,233,231,228,226,223,221,218,216,213,210,208,205,202,200,197,194,192,189,187,185,182,180,178,175,172,170,167,164,161,158,155,152,148,145,142,138,135,132,128,125,122,118,115,111,108,105,102,98,95,92,89,86,83,81,78,75,73,71,68,66,64,63,61,60,58,57,56,55,54,54,53,53,52,52,52,52,52,52,52,52,52,53,53,53,54,54,55,55,55,56,56,57,57,57,58,58,58,58,58,58,58,58,58,57,57,57,56,55,54,54,53,52,51,50,49,48,47,45,44,43,42,41,39,38,37,35,34,33,31,30,29,28,26,25,24,23,21,20,19,18,17,16,15,14,13,12,12,11,10,10,9,8,8,7,7,6,6,5,5,5,4,4,4,3,3,3,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,3 };

    int channels = b.channels();

    int nRows = b.rows;
    int nCols = b.cols * channels;

    if (b.isContinuous())
    {
        nCols *= nRows;
        nRows = 1;
    }

    int i, j;
    uchar* pb, *pg, *pr;
    for (i = 0; i < nRows; ++i)
    {
        pb = b.ptr<uchar>(i);
        pg = g.ptr<uchar>(i);
        pr = r.ptr<uchar>(i);
        for (j = 0; j < nCols; ++j)
        {
            pb[j] = turbo_b[pb[j]];
            pg[j] = turbo_g[pg[j]];
            pr[j] = turbo_r[pr[j]];
        }
    }
    cv::Mat dst(b.size(), CV_8UC3);
    std::vector<cv::Mat> t = { b,g,r };
    cv::merge(t, dst);
    return dst;
}
cv::Mat image2winter(const cv::Mat& src) {
    cv::Mat b = src.clone();
    if (src.type() != CV_8UC1) {
        double min;
        double max;
        cv::minMaxIdx(src, &min, &max);
        // expand your range to 0..255. Similar to histEq();
        src.convertTo(b, CV_8UC1, 255 / (max - min), -min);
    }
    cv::Mat g = b.clone();
    cv::Mat r = b.clone();
    unsigned char winter_r[256] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    unsigned char winter_g[256] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255 };
    unsigned char winter_b[256] = { 255, 254, 254, 254, 253, 252, 252, 252, 251, 250, 250, 250, 249, 248, 248, 248, 247, 246, 246, 246, 245, 244, 244, 244, 243, 242, 242, 242, 241, 240, 240, 240, 239, 238, 238, 238, 237, 236, 236, 236, 235, 234, 234, 234, 233, 232, 232, 232, 231, 230, 230, 230, 229, 228, 228, 228, 227, 226, 226, 226, 225, 224, 224, 224, 223, 222, 222, 222, 221, 221, 220, 220, 219, 219, 218, 218, 217, 217, 216, 216, 215, 215, 214, 214, 213, 213, 212, 212, 211, 211, 210, 210, 209, 209, 208, 208, 207, 206, 206, 206, 205, 204, 204, 204, 203, 202, 202, 202, 201, 200, 200, 200, 199, 198, 198, 198, 197, 196, 196, 196, 195, 194, 194, 194, 193, 192, 192, 192, 191, 190, 190, 190, 189, 188, 188, 188, 187, 186, 186, 186, 185, 184, 184, 184, 183, 182, 182, 182, 181, 180, 180, 180, 179, 178, 178, 178, 177, 176, 176, 176, 175, 174, 174, 174, 173, 172, 172, 172, 171, 170, 170, 170, 169, 168, 168, 168, 167, 166, 166, 166, 165, 164, 164, 164, 163, 162, 162, 162, 161, 160, 160, 160, 159, 158, 158, 158, 157, 156, 156, 156, 155, 154, 154, 154, 153, 152, 152, 152, 151, 150, 150, 150, 149, 148, 148, 148, 147, 146, 146, 146, 145, 144, 144, 144, 143, 142, 142, 142, 141, 140, 140, 140, 139, 138, 138, 138, 137, 136, 136, 136, 135, 134, 134, 134, 133, 132, 132, 132, 131, 130, 130, 130, 129, 128, 128, 128 };

    int channels = b.channels();

    int nRows = b.rows;
    int nCols = b.cols * channels;

    if (b.isContinuous())
    {
        nCols *= nRows;
        nRows = 1;
    }

    int i, j;
    uchar* pb, *pg, *pr;
    for (i = 0; i < nRows; ++i)
    {
        pb = b.ptr<uchar>(i);
        pg = g.ptr<uchar>(i);
        pr = r.ptr<uchar>(i);
        for (j = 0; j < nCols; ++j)
        {
            pb[j] = winter_b[pb[j]];
            pg[j] = winter_g[pg[j]];
            pr[j] = winter_r[pr[j]];
        }
    }
    cv::Mat dst(b.size(), CV_8UC3);
    std::vector<cv::Mat> t = { b,g,r };
    cv::merge(t, dst);
    return dst;
}

//cv::Mat depth2normal(const cv::Mat &src) {
//    cv::Mat normal = cv::Mat(src.size(), CV_8UC3, cv::Scalar(0));
//    for (int y = 0; y < src.rows; ++y)
//    {
//        for (int x = 0; x < src.cols; ++x)
//        {
//            ushort d = src.ptr<ushort>(y)[x];
//            if ( (x + 1) >= src.cols || (y + 1) >= src.rows || d == 0) {
//                continue;
//            }
//            cv::Vec3b center(src.at<cv::Vec3b>(y, x));
//            cv::Vec3b center_down_neibor(src.at<cv::Vec3b>(y+1, x));
//            cv::Vec3b center_right_neibor(src.at<cv::Vec3b>(y, x+1));
//            center_right_neibor -= center;
//            center_down_neibor -= center;
//            cv::Vec3b n = center_down_neibor.cross(center_right_neibor);
//            normal.at<cv::Vec3b>(y, x) = cv::normalize(n);
//        }
//    }
//    return normal;
//}

// DEBUG
void PrintMat(const cv::Mat &one_channel_image) {
    if (one_channel_image.empty()) {
        cout << "PrintMat: image is empty";
        return;
    }

    for (int y = 0; y < one_channel_image.rows; y++) {
        for (int x = 0; x < one_channel_image.cols; x++) {
            /*cout << one_channel_image.at<float>(y, x);
            cout << " ";*/
            printf("%7.6f ", one_channel_image.at<double>(y, x));
        }
        cout << endl;
    }
    cout << endl;
}
//const int CHOICES = 14;

void Widget::initColoScale()
{
//    cv::Mat disp(cv::Size(ui->AutumnScaleLabel->width(), ui->AutumnScaleLabel->height()), CV_8UC1, cv::Scalar(0));
    cv::Mat disp(cv::Size(256, 19), CV_8UC1, cv::Scalar(0));

    for (int y = 0; y < disp.rows; y++)
    {
        for (int x = 0; x < disp.cols; x++)
        {
            disp.at<uchar>(y, x) = static_cast<uchar>(x);
        }
    }

    ui->AutumnScaleLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(image2autumn(disp))));
    ui->BoneScaleLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(image2bone(disp))));
    ui->CoolScaleLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(image2cool(disp))));
    ui->HotScaleLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(image2hot(disp))));
    ui->HsvScaleLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(image2hsv(disp))));
    ui->JetScaleLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(image2jet(disp))));
    ui->OceanScaleLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(image2ocean(disp))));
    ui->ParulaScaleLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(image2parula(disp))));
    ui->PinkScaleLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(image2pink(disp))));
    ui->RainbowScaleLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(image2rainbow(disp))));
    ui->SpringScaleLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(image2spring(disp))));
    ui->SummerScaleLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(image2summer(disp))));
    ui->TurboScaleLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(image2turbo(disp))));
    ui->WinterScaleLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(image2winter(disp))));
}


Widget::Widget(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::Widget)
{
    ui->setupUi(this);
    // set up fixed size
    this->setFixedSize(this->size());


    // set up for drawing image on label to display
    this->setAcceptDrops(true);
    ui->RawImageLabel->setAcceptDrops(true);


    //  set up the lable border and initilize some variables
    //ui->RawImageLabel->setStyleSheet("QLabel{border:3px solid rgb(0, 0, 0);}");
    ui->RawImageLabel->setStyleSheet("background-color:gray");

    // init scaleLabel
    initColoScale();

    // init radionLable
    OptionGroups = new QButtonGroup(this);
    OptionGroups->addButton(ui->RawRadioButton, 0);
    OptionGroups->addButton(ui->AutumnRadioButton, 1);
    OptionGroups->addButton(ui->BoneRadioButton, 2);
    OptionGroups->addButton(ui->CoolRadioButton, 3);
    OptionGroups->addButton(ui->HotRadioButton, 4);
    OptionGroups->addButton(ui->HsvRadioButton, 5);
    OptionGroups->addButton(ui->JetRadioButton, 6);
    OptionGroups->addButton(ui->OceanRadioButton, 7);
    OptionGroups->addButton(ui->ParulaRadioButton, 8);
    OptionGroups->addButton(ui->PinkRadioButton, 9);
    OptionGroups->addButton(ui->RainbowRadioButton, 10);
    OptionGroups->addButton(ui->SpringRadioButton, 11);
    OptionGroups->addButton(ui->SummerRadioButton, 12);
    OptionGroups->addButton(ui->TurboRadioButton, 13);
    OptionGroups->addButton(ui->WinterRadioButton, 14);

    // init checked option
    ui->AutumnRadioButton->setChecked(true);


    connect(ui->RawRadioButton, SIGNAL(clicked()), this, SLOT(on_OptionGroups()));
    connect(ui->AutumnRadioButton, SIGNAL(clicked()), this, SLOT(on_OptionGroups()));
    connect(ui->BoneRadioButton, SIGNAL(clicked()), this, SLOT(on_OptionGroups()));
    connect(ui->CoolRadioButton, SIGNAL(clicked()), this, SLOT(on_OptionGroups()));
    connect(ui->HotRadioButton, SIGNAL(clicked()), this, SLOT(on_OptionGroups()));
    connect(ui->HsvRadioButton, SIGNAL(clicked()), this, SLOT(on_OptionGroups()));
    connect(ui->JetRadioButton, SIGNAL(clicked()), this, SLOT(on_OptionGroups()));
    connect(ui->OceanRadioButton, SIGNAL(clicked()), this, SLOT(on_OptionGroups()));
    connect(ui->ParulaRadioButton, SIGNAL(clicked()), this, SLOT(on_OptionGroups()));
    connect(ui->PinkRadioButton, SIGNAL(clicked()), this, SLOT(on_OptionGroups()));
    connect(ui->RainbowRadioButton, SIGNAL(clicked()), this, SLOT(on_OptionGroups()));
    connect(ui->SpringRadioButton, SIGNAL(clicked()), this, SLOT(on_OptionGroups()));
    connect(ui->SummerRadioButton, SIGNAL(clicked()), this, SLOT(on_OptionGroups()));
    connect(ui->TurboRadioButton, SIGNAL(clicked()), this, SLOT(on_OptionGroups()));
    connect(ui->WinterRadioButton, SIGNAL(clicked()), this, SLOT(on_OptionGroups()));
}

Widget::~Widget()
{
    delete ui;
}

void Widget::dragEnterEvent(QDragEnterEvent *event)
{
    if (event->type() != QEvent::DragEnter) return;
    // for linux:event->mimeData()->urls()[0].toLocalFile().right(3).compare("bmp")
    if (!event->mimeData()->urls()[0].toLocalFile().right(3).compare("bmp") ||
        !event->mimeData()->urls()[0].toLocalFile().right(3).compare("jpg") ||
        !event->mimeData()->urls()[0].toLocalFile().right(3).compare("pbm") ||
        !event->mimeData()->urls()[0].toLocalFile().right(3).compare("pgm") ||
        !event->mimeData()->urls()[0].toLocalFile().right(3).compare("png") ||
        !event->mimeData()->urls()[0].toLocalFile().right(3).compare("ppm") ||
        !event->mimeData()->urls()[0].toLocalFile().right(3).compare("xbm") ||
        !event->mimeData()->urls()[0].toLocalFile().right(3).compare("xpm"))
    {
        event->acceptProposedAction();
    }
    else
    {
        event->ignore();
    }
}
void Widget::dropEvent(QDropEvent *event)
{
    if (event->type() != QEvent::Drop) return;
    QList<QUrl> urls = event->mimeData()->urls();
    QString path = urls.first().toLocalFile();
    if (!path.isEmpty())
    {
        //src = imread(string((const char *)path.toLocal8Bit()), -1);
        string tmp = static_cast<string>(static_cast<const char*>(path.toLocal8Bit()));
        src = imread(tmp, -1);
        if (src.channels() > 1)
        {
            ui->RawImageLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(src)));
        }
        else
        {
            on_OptionGroups();
        }
    }
//    else
//    {
//        QMessageBox mes;
//        mes.warning(this, tr("warning!"),tr("Failed to open image"));
//    }
}

void Widget::on_OptionGroups()
{
    if (src.channels() > 1 || src.empty()) return;
    switch (OptionGroups->checkedId())
    {
        case 0:
            //colormap = src.clone();
            ui->RawImageLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(src)));
            break;
        case 1:
            colormap = image2autumn(src);
            ui->RawImageLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(colormap)));
            break;
        case 2:
            colormap = image2bone(src);
            ui->RawImageLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(colormap)));
            break;
        case 3:
            colormap = image2cool(src);
            ui->RawImageLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(colormap)));
            break;
        case 4:
            colormap = image2hot(src);
            ui->RawImageLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(colormap)));
            break;
        case 5:
            colormap = image2hsv(src);
            ui->RawImageLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(colormap)));
            break;
        case 6:
            colormap = image2jet(src);
            ui->RawImageLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(colormap)));
            break;
        case 7:
            colormap = image2ocean(src);
            ui->RawImageLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(colormap)));
            break;
        case 8:
            colormap = image2parula(src);
            ui->RawImageLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(colormap)));
            break;
        case 9:
            colormap = image2pink(src);
            ui->RawImageLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(colormap)));
            break;
        case 10:
            colormap = image2rainbow(src);
            ui->RawImageLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(colormap)));
            break;
        case 11:
            colormap = image2spring(src);
            ui->RawImageLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(colormap)));
            break;
        case 12:
            colormap = image2summer(src);
            ui->RawImageLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(colormap)));
            break;
        case 13:
            colormap = image2turbo(src);
            ui->RawImageLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(colormap)));
            break;
        case 14:
            colormap = image2winter(src);
            ui->RawImageLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(colormap)));
            break;
    }
}

void Widget::on_LoadButton_clicked()
{

    QPixmap image;
    QString fileName = QFileDialog::getOpenFileName(
                    this, tr("open image file"),
                    "./", tr("Image files(*.bmp *.jpg *.pbm *.pgm *.png *.ppm *.xbm *.xpm *.ico);;All files (*.*)"));
    if (fileName.isEmpty())
    {
//        QMessageBox mes;
//        mes.warning(this, tr("warning!"),tr("Failed to open image"));
        return;
    }
    else
    {
        // src = imread(fileName.toLatin1().data(), -1);
        // solve the chinese path
        string tmp = static_cast<string>(static_cast<const char*>(fileName.toLocal8Bit()));
        src = imread(tmp, -1);
        if (src.channels() > 1)
        {
            //ui->RawImageLabel->resize(width,height);
            ui->RawImageLabel->setPixmap(QPixmap::fromImage(cvMat2QImage(src)));
        }
        else
        {
            on_OptionGroups();
        }

    }

}



//void Widget::on_AutumnRadioButton_toggled(bool checked)
//{
//    if (ui->AutumnRadioButton->isChecked())
//    {
//        qDebug() << "Autumn button is checked !";
//    }
//    else
//    {
//        qDebug() << "Autumn button is not checked !";
//    }
//}

//void Widget::on_BoneRadioButton_toggled(bool checked)
//{
//    if (ui->BoneRadioButton->isChecked())
//    {
//        qDebug() << "Bone button is checked !";
//    }
//    else
//    {
//        qDebug() << "Bone button is not checked !";
//    }
//}

//void Widget::on_AutumnRadioButton_clicked()
//{
//    qDebug() << "Autumn button is checked !";
//}



